<?php
/*
 * This file is part of the `nicolab/php-ftp-client` package.
 *
 * (c) Nicolas Tallefourtane <dev@nicolab.net>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @copyright Nicolas Tallefourtane http://nicolab.net
 */
namespace SftpClient;

use FtpClient\FtpWrapper;

class SftpWrapper extends FtpWrapper
{
    protected $conn;
    protected $sftp;
    protected $cwd = "/";

    /**
     * Connect to the server
     *
     * @param string $host
     * @param int $port
     * @param int $timeout
     * @return false|resource
     */
    public function connect($host, $port = 22, $timeout = 90)
    {
        return $this->conn = @ssh2_connect($host, $port);
    }

    /**
     * Close the connection
     *
     * @return bool
     */
    public function close()
    {
        return @ssh2_disconnect($this->conn);
    }

    /**
     * @param $username
     * @param $password
     * @return bool|resource
     * @throws FtpException
     */
    function login($username, $password){
        if (! @ssh2_auth_password($this->conn, $username, $password))
            throw new FtpException("Could not authenticate with username $username " .
                "and password $password.");

        $this->sftp = @ssh2_sftp($this->conn);
        if (! $this->sftp){
            throw new FtpException("Could not initialize SFTP subsystem.");
        }
        return $this->sftp;
    }
    /**
     * Forward the method call to SFTP functions
     *
     * @param  string       $function
     * @param  array        $arguments
     * @return mixed
     * @throws FtpException When the function is not valid
     */
    public function __call($function, array $arguments)
    {
        if(method_exists($this, $function)){
            return @call_user_func_array([$this,$function],$arguments);
        }
        $function = 'ssh2_sftp_'. $function;
        if (function_exists($function)) {
            if(!empty($arguments[0])){
                $arguments[0] = $this->_getworkdir($arguments[0]);
            }
            array_unshift($arguments, $this->sftp);
            return @call_user_func_array($function, $arguments);
        }

        throw new FtpException("{$function} is not a valid sFTP function");
    }


    /**
     * Pasive mode does not exist in sFTP
     * @param  bool $pasv
     * @return bool
     */
    public function pasv($pasv)
    {
        return true;
    }

    /**
     * return the current working directory
     */
    public function pwd()
    {
        return $this->cwd;
    }

    /**
     * Raw is execute a command on the server
     * @param string $command
     * @return array
     */
    function raw(string $command): array
    {
       return @ssh2_exec($this->sftp,$command); // TODO: Change the autogenerated stub
    }

    /**
     * return the modify time of a file
     */
    public function mdtm($file)
    {
        return filemtime($this->_getsshdir($file));
    }

    /**
     * return the current working directory
     */
    public function chdir($dir)
    {
        if (is_dir($this->_getsshdir($dir))) {
            $this->cwd = $this->_getworkdir($dir);
            return true;
        }
        return false;
    }

    /**
     * Make remote directory
     * @param $dir
     * @return false|string
     */
    public function mkdir($dir,$mode = 0755)
    {
        $path = $this->_getworkdir($dir);
        if(ssh2_sftp_mkdir($this->sftp, $path,$mode)){
            return "/".$dir;
        }
        return false;
    }


    public function get($local_file,$remote_file)
    {
        $remote_file = $this->_getworkdir($remote_file);
        return @ssh2_scp_recv($this->conn, $remote_file,$local_file);
    }

    public function put($remote_file, $local_file, $mode = 0664)
    {
        $remote_file = $this->_getworkdir($remote_file);
        return @ssh2_scp_send($this->conn, $local_file, $remote_file, $mode);
    }

    public function delete($file)
    {
        return @ssh2_sftp_unlink($this->sftp, $this->_getworkdir($file));
    }

    protected function _getworkdir($dir){
        if($dir == "."){
            return $this->cwd;
        }
        if($dir == ".."){
            return dirname($this->cwd);
        }
        if(substr($dir, 0,1)=="/"){
            return $dir;
        }
        return rtrim($this->cwd,"/")."/".$dir;
    }
    protected function _getsshdir($dir){
        $dir = $this->_getworkdir($dir);
        return "ssh2.sftp://".intval($this->sftp)."/".$dir;
    }

    public function nlist($dir){
        $list = [];
        $sshdir = $this->_getsshdir($dir);
        $workdir = $this->_getworkdir($dir);
        if (!is_dir($sshdir)) {
            return false;
        }
        if ($dh = opendir($sshdir)) {
            while (($file = readdir($dh)) !== false) {
                if (substr($file, 0, 1) == ".") {
                    continue;
                }
                if (is_dir($sshdir . '/' . $file)) {
                    $list[] = $workdir."/".$file;
                }elseif (is_readable($sshdir . '/' . $file)) {
                    $list[] = $workdir."/".$file;
                }
            }
            closedir($dh);
        }
        return $list;
    }
    public function rawlist($dir)
    {
        $list = $this->nlist($dir);
        if(!is_array($list)){
            return false;
        }
        $rawlist = [];
        //$dir = $this->_getworkdir($dir);
        foreach($list as $nr=>$file){
            $statinfo = ssh2_sftp_stat($this->sftp, $file);
            $rawlist[] = sprintf("%s %s %s %s %s %s %s %s %s",
                $this->_permissionsToString($statinfo['mode']),
                $nr,
                $statinfo['uid'],
                $statinfo['gid'],
                $statinfo['size'],
                date("M", $statinfo['mtime']),
                date("d", $statinfo['mtime']),
                date("Y", $statinfo['mtime']),
                basename($file)
            );
        }
        return $rawlist;
    }

    protected function _permissionsToString($perms) {
        switch ($perms & 0xF000) {
            case 0xC000: // socket
                $info = 's';
                break;
            case 0xA000: // symbolic link
                $info = 'l';
                break;
            case 0x8000: // regular
                $info = '-';
                break;
            case 0x6000: // block special
                $info = 'b';
                break;
            case 0x4000: // directory
                $info = 'd';
                break;
            case 0x2000: // character special
                $info = 'c';
                break;
            case 0x1000: // FIFO pipe
                $info = 'p';
                break;
            default: // unknown
                $info = 'u';
        }

        // Owner
        $info .= (($perms & 0x0100) ? 'r' : '-');
        $info .= (($perms & 0x0080) ? 'w' : '-');
        $info .= (($perms & 0x0040) ?
            (($perms & 0x0800) ? 's' : 'x' ) :
            (($perms & 0x0800) ? 'S' : '-'));

        // Group
        $info .= (($perms & 0x0020) ? 'r' : '-');
        $info .= (($perms & 0x0010) ? 'w' : '-');
        $info .= (($perms & 0x0008) ?
            (($perms & 0x0400) ? 's' : 'x' ) :
            (($perms & 0x0400) ? 'S' : '-'));

        // World
        $info .= (($perms & 0x0004) ? 'r' : '-');
        $info .= (($perms & 0x0002) ? 'w' : '-');
        $info .= (($perms & 0x0001) ?
            (($perms & 0x0200) ? 't' : 'x' ) :
            (($perms & 0x0200) ? 'T' : '-'));

        return $info;
    }
}
